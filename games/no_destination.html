<!DOCTYPE HTML>
<html>

<!--
	Hi! If you're reading this, that probably means your browser 
	doesn't support downloading your bitsy game directly.

	Don't panic!

	All you need to do now is save this page as an ".html" file.
	You should be able to use cmd-s or ctrl-s to save. Then
	you may be given multiple download formats; if so, pick
	"page source" or the closest looking thing.

	The most important thing is when you save, you name the file
	"mygame.html" or something similar. Your browser may ask
	to append ".txt" or something, but don't do that. It should
	end in ".html" so your computer knows it's a webpage. 

	Now you should be able to click on your game and play it 
	in your browser!

	- adam
-->

<!-- HEADER -->
<head>

<title>no destination</title>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#000;
}

#game {
	background:black;
	width:90vw;
	max-width:90vh;
	margin:auto;
	margin-top:5vh;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
var exportedGameData = "no destination\n\n# BITSY VERSION 3.7\n\n! ROOM_FORMAT 1\n\nPAL 0\n47,19,53\n239,174,143\n180,252,190\n\nPAL 1\n98,35,103\n255,196,255\n255,255,255\n\nPAL 2\n67,47,91\n214,205,218\n180,252,190\n\nPAL 3\n33,56,43\n242,226,189\n180,252,190\n\nPAL 4\n73,92,95\n218,233,252\n180,252,190\n\nPAL 5\n1,50,43\n210,237,150\n180,252,190\n\nPAL 6\n38,33,32\n227,185,196\n180,252,190\n\nROOM 0\ns,r,r,r,r,s,0,0,0,0,0,0,0,0,0,0\nq,n,m,m,o,q,0,0,0,0,0,0,0,0,0,0\nq,n,m,m,o,q,0,0,0,0,0,0,0,0,0,0\nq,c,m,m,p,q,0,0,0,0,0,0,0,0,0,0\nq,u,v,l,t,q,0,0,0,0,0,0,0,0,0,0\nq,j,d,d,k,q,0,0,0,0,0,0,0,0,0,0\nq,g,e,e,f,q,0,0,0,0,0,0,0,0,0,0\nq,x,y,z,w,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\ns,r,r,r,r,s,0,0,0,0,0,0,0,0,0,0\nWAL h,g,e,f,i,k,j,v,q,r,s,11,12,10,17,1b,1a,1h,1i,1z,1k,1j\nEXT 3,4 1 7,4\nPAL 6\n\nROOM 1\ns,r,r,r,r,s,s,r,r,r,r,r,r,r,r,s\nq,n,m,m,o,q,q,1a,10,10,1b,1a,10,10,1b,q\nq,n,m,m,o,q,q,14,20,11,13,0,11,21,13,q\nq,c,m,m,p,q,q,15,12,12,16,15,12,12,16,q\nq,u,v,l,t,q,1c,1n,1n,1n,1n,1n,1n,1n,1n,23\nq,j,d,d,k,q,q,19,22,17,18,19,22,17,18,q\nq,g,e,e,f,q,s,r,r,r,r,r,r,r,r,s\nq,x,y,z,w,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\ns,r,r,r,r,s,0,0,0,0,0,0,0,0,0,0\nWAL h,g,e,f,i,k,j,q,r,s,11,12,10,17,1b,1a,1h,1i,1z,1k,1j\nEXT 6,4 0 3,5\nEXT 7,2 3 7,2\nEXT 14,2 4 14,2\nEXT 11,5 5 11,5\nEXT 7,5 6 7,5\nEXT 15,4 8 7,4\nPAL 0\n\nROOM 3\ns,r,r,r,r,s,s,r,r,r,r,r,r,r,r,s\nq,n,m,m,o,q,q,1a,10,10,1b,1a,10,10,1b,q\nq,n,m,m,o,q,q,14,11,11,13,14,11,11,13,q\nq,c,m,m,p,q,q,15,12,12,16,15,12,12,16,q\nq,u,v,l,t,q,1c,1n,1n,1n,1n,1n,1n,1n,1n,q\nq,j,d,d,k,q,q,19,17,17,18,19,17,17,18,q\nq,g,e,e,f,q,s,r,r,r,r,r,r,r,r,s\nq,x,y,z,w,q,s,r,r,r,r,r,r,r,r,s\nq,0,a,b,0,q,q,1i,0,0,1h,0,0,1i,0,q\nq,0,a,b,0,q,q,0,1h,0,0,1h,1d,1e,0,q\nq,0,a,b,0,q,q,0,0,1d,1e,1d,1g,1f,1e,q\nq,0,a,b,0,q,q,1e,1d,1g,1f,1e,1j,1k,1j,q\nq,0,a,b,0,q,q,1d,1g,1j,1k,1j,1k,1l,1k,q\nq,0,a,b,0,q,q,1j,1k,1j,1k,0,1j,1k,1l,q\nq,0,a,b,0,q,q,0,1j,1l,1l,1j,1l,1l,1k,q\ns,r,r,r,r,s,s,r,r,r,r,r,r,r,r,s\nWAL h,g,e,f,i,k,j,q,r,s,11,12,10,17,1b,1a,1h,1i,1z,1k,1j\nEXT 3,4 1 7,4\nEXT 6,4 3 3,5\nPAL 4\n\nROOM 4\ns,r,r,r,r,s,s,r,r,r,r,r,r,r,r,s\nq,n,m,m,o,q,q,1a,10,10,1b,1a,10,10,1b,q\nq,n,m,m,o,q,q,14,11,11,13,14,11,11,13,q\nq,c,m,m,p,q,q,15,12,12,16,15,12,12,16,q\nq,u,v,l,t,q,1c,1n,1n,1n,1n,1n,1n,1n,1n,q\nq,j,d,d,k,q,q,19,17,17,18,19,17,17,18,q\nq,g,e,e,f,q,s,r,r,r,r,r,r,r,r,s\nq,x,y,z,w,q,s,r,r,r,r,r,r,r,r,s\nq,0,a,b,0,q,q,0,1h,0,1i,1q,1s,1u,0,q\nq,0,a,b,0,q,q,0,0,1i,0,1q,1s,0,1h,q\nq,0,a,b,0,q,q,1h,0,0,1p,1q,1t,1i,0,q\nq,0,a,b,0,q,q,0,1i,0,1q,1r,1u,0,1i,q\nq,0,a,b,0,q,q,1k,1j,1l,1q,1s,1k,0,1j,q\nq,0,a,b,0,q,q,1l,1k,1p,1s,1t,1j,1l,1k,q\nq,0,a,b,0,q,q,1k,0,1q,1j,1l,1k,0,1j,q\ns,r,r,r,r,s,s,r,r,r,r,r,r,r,r,s\nWAL h,g,e,f,i,k,j,q,r,s,11,12,10,17,1b,1a,1h,1i,1z,1k,1j\nEXT 3,4 1 7,4\nEXT 6,4 4 3,5\nPAL 3\n\nROOM 5\ns,r,r,r,r,s,s,r,r,r,r,r,r,r,r,s\nq,n,m,m,o,q,q,1a,10,10,1b,1a,10,10,1b,q\nq,n,m,m,o,q,q,14,11,11,13,14,11,11,13,q\nq,c,m,m,p,q,q,15,12,12,16,15,12,12,16,q\nq,u,v,l,t,q,1c,1n,1n,1n,1n,1n,1n,1n,1n,q\nq,j,d,d,k,q,q,19,17,17,18,19,17,17,18,q\nq,g,e,e,f,q,s,r,r,r,r,r,r,r,r,s\nq,x,y,z,w,q,s,r,r,r,r,r,r,r,r,s\nq,0,a,b,0,q,q,1k,1o,1e,0,1j,1s,1e,1d,q\nq,0,a,b,0,q,q,1e,1u,1f,1e,1p,1g,1f,1f,q\nq,0,a,b,0,q,q,1f,1g,0,1f,1g,1f,12,1f,q\nq,0,a,b,0,q,q,18,0,0,1p,0,13,1c,0,q\nq,0,a,b,0,q,q,14,19,1o,1x,1x,1x,0,18,q\nq,0,a,b,0,q,q,1x,1x,1g,0,1w,0,1f,1x,q\nq,0,a,b,0,q,q,1w,0,1w,0,0,0,1w,0,q\ns,r,r,r,r,s,s,r,r,r,r,r,r,r,r,s\nWAL h,g,e,f,i,k,j,q,r,s,11,12,10,17,1b,1a,1h,1i,1z,1k,1j\nEXT 3,4 1 7,4\nEXT 6,4 5 3,5\n\nROOM 6\ns,r,r,r,r,s,s,r,r,r,r,r,r,r,r,s\nq,n,m,m,o,q,q,1a,10,10,1b,1a,10,10,1b,q\nq,n,m,m,o,q,q,14,11,11,13,14,11,11,13,q\nq,c,m,m,p,q,q,15,12,12,16,15,12,12,16,q\nq,u,v,l,t,q,1c,1n,1n,1n,1n,1n,1n,1n,1n,q\nq,j,d,d,k,q,q,19,17,17,18,19,17,17,18,q\nq,g,e,e,f,q,s,r,r,r,r,r,r,r,r,s\nq,x,y,z,w,q,s,r,r,r,r,r,r,r,r,s\nq,0,a,b,0,q,q,0,1i,0,1d,1e,0,1h,0,q\nq,0,a,b,0,q,q,1j,1k,1l,1a,1b,1l,1k,1k,q\nq,0,a,b,0,q,q,0,1w,1x,0,0,1w,1x,0,q\nq,0,a,b,0,q,q,1w,1x,0,1w,0,0,0,1w,q\nq,0,a,b,0,q,q,0,0,0,0,1w,1x,0,0,q\nq,0,a,b,0,q,q,1w,0,0,0,0,0,0,1w,q\nq,0,a,b,0,q,q,0,1w,1x,0,0,1w,0,0,q\ns,r,r,r,r,s,s,r,r,r,r,r,r,r,r,s\nWAL h,g,e,f,i,k,j,q,r,s,11,12,10,17,1b,1a,1h,1i,1z,1k,1j\nEXT 3,4 1 7,4\nEXT 6,4 6 3,5\nPAL 2\n\nROOM 7\n0,0,0,0,1i,0,s,r,r,1l,1k,0,0,0,0,0\n0,1j,1k,0,0,0,q,0,1h,0,0,1i,0,0,0,0\n0,0,0,0,0,1j,1l,1j,1k,1i,0,0,0,1h,0,0\n0,1i,0,0,1j,1l,1k,1k,1z,1z,1z,1z,1z,1z,0,0\n1k,0,0,0,0,1j,1l,1f,1f,1f,1f,1y,0,1z,1h,0\n0,0,1h,0,1j,1l,1k,1l,1k,1z,1z,0,1i,1z,0,0\n0,0,0,0,0,0,s,r,1l,1k,0,0,0,0,0,0\n1j,1l,1k,0,1i,0,0,0,1i,0,0,0,0,0,0,0\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,1i,0\n0,1i,0,0,0,0,0,0,0,0,1h,0,0,0,0,0\n0,0,0,0,0,1h,0,0,0,0,0,0,0,0,0,0\n0,0,0,0,0,0,0,0,1i,0,0,0,0,0,0,0\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n0,0,0,0,0,0,0,0,0,0,0,0,0,1i,0,0\n0,0,1i,0,0,0,0,0,0,0,0,0,0,0,0,0\n0,0,0,0,0,0,0,1h,0,0,0,0,0,0,0,0\nWAL h,g,e,f,i,k,j,q,r,s,11,12,10,17,1b,1a,1h,1i,1z,1k,1j\nEXT 6,4 1 14,4\nEND undefined 12,4\n\nROOM 8\ns,r,r,r,r,s,s,r,r,1l,1k,0,0,0,0,0\nq,1j,1l,m,o,q,q,0,1h,0,0,1i,0,0,0,0\nq,n,m,m,o,1j,1l,1j,1k,1i,0,0,0,1h,0,0\nq,c,m,m,1j,1l,1k,1k,1z,1z,1z,1z,1z,1z,0,0\n1k,u,v,l,t,1j,1l,1f,1f,1f,1f,1y,0,1z,1h,0\nq,j,d,d,1j,1l,1k,1l,1k,1z,1z,0,1i,1z,0,0\nq,g,e,e,f,q,s,r,1l,1k,0,0,0,0,0,0\n1j,1l,1l,z,w,q,0,0,1i,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,1i,0\nq,0,a,b,0,q,0,0,0,0,1h,0,0,0,0,0\nq,0,a,b,0,q,0,0,0,0,0,0,0,0,0,0\nq,0,a,b,0,q,0,0,1i,0,0,0,0,0,0,0\nq,0,a,b,0,1c,0,0,0,0,0,0,0,0,0,0\n1c,0,a,b,0,1c,0,0,0,0,0,0,0,1i,0,0\n1c,0,a,b,0,1c,0,0,0,0,0,0,0,0,0,0\ns,r,r,r,r,s,0,1h,0,0,0,0,0,0,0,0\nWAL h,g,e,f,i,k,j,q,r,s,11,12,10,17,1b,1a,1h,1i,1z,1k,1j\nEXT 6,4 0 3,5\nEND undefined 12,4\nPAL 1\n\nTIL 10\n00000000\n11111111\n00000000\n00100010\n00000000\n11001100\n00000000\n11111111\n>\n00000000\n11111111\n00000000\n10001000\n00000000\n00110011\n00000000\n11111111\n\nTIL 11\n00000000\n11111111\n11111111\n00000000\n11111111\n11111111\n11111111\n11111111\n\nTIL 12\n11111111\n11111111\n11111111\n11111111\n00000000\n00111100\n00111100\n00000000\n\nTIL 13\n01111111\n11111111\n11111111\n00000000\n00001110\n00001110\n01101110\n01101110\n\nTIL 14\n11111110\n11111111\n11111111\n00000000\n01110000\n01110000\n01110110\n01110110\n\nTIL 15\n01110110\n01110110\n01110110\n00000110\n01110110\n01110000\n01110110\n01110110\n\nTIL 16\n01101110\n01101110\n01101110\n01100000\n01101110\n00001110\n01101110\n01101110\n\nTIL 17\n00000000\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n\nTIL 18\n00001110\n00001110\n01101110\n01101110\n01101110\n01101110\n01101110\n01101110\n\nTIL 19\n01110000\n01110000\n01110110\n01110110\n01110110\n01110110\n01110110\n01110110\n\nTIL 20\n00000000\n11111111\n11111111\n00000000\n11111111\n10101111\n11111111\n10101111\n>\n00000000\n11111111\n11111111\n00000000\n11111111\n11011111\n10101111\n11011111\n\nTIL 21\n00000000\n11111111\n11111111\n00000000\n11111111\n11111011\n11110101\n11111011\n>\n00000000\n11111111\n11111111\n00000000\n11111111\n11110101\n11111111\n11110101\n\nTIL 22\n00000000\n11111111\n11111111\n11111111\n10101111\n11111111\n10101111\n11111111\n>\n00000000\n11111111\n11111111\n11111111\n11011111\n10101111\n11011111\n11111111\n\nTIL 23\n00011000\n00011000\n10011000\n01011000\n10011000\n01011000\n10011000\n00011000\n\nTIL a\n00100000\n10101111\n10101111\n10101111\n00100000\n00100000\n00100000\n00100000\n>\n00100000\n00100000\n00100000\n00100000\n00100000\n10101111\n10101111\n10101111\n\nTIL b\n00000100\n11110101\n11110101\n11110101\n00000100\n00000100\n00000100\n00000100\n>\n00000100\n00000100\n00000100\n00000100\n00000100\n11110101\n11110101\n11110101\n\nTIL c\n00001011\n00000010\n00001000\n00000001\n00001011\n00000010\n00001000\n00001111\n>\n00000010\n00001000\n00000001\n00001011\n00000010\n00001000\n00001111\n00000000\n\nTIL d\n00000000\n01010101\n10101010\n01010101\n10101010\n01010101\n10101010\n01010101\n>\n01010101\n10101010\n01010101\n10101010\n01010101\n10101010\n01010101\n10101010\n\nTIL e\n10101010\n01010101\n10101010\n00000000\n11111111\n00100010\n00100010\n00100010\n>\n01010101\n10101010\n00000000\n11111111\n00100010\n00100010\n00100010\n00000000\n\nTIL f\n10100000\n00100000\n10100000\n00100000\n11100000\n01000000\n01000000\n01000000\n>\n00100000\n10100000\n00100000\n11100000\n01000000\n01000000\n01000000\n00000000\n\nTIL g\n00000100\n00000101\n00000100\n00000100\n00000111\n00000010\n00000010\n00000010\n>\n00000101\n00000100\n00000100\n00000111\n00000010\n00000010\n00000010\n00000000\n\nTIL h\n00000100\n00000100\n00000100\n00000100\n00000100\n00000100\n00000100\n00000100\n\nTIL i\n00100000\n00100000\n00100000\n00100000\n00100000\n00100000\n00100000\n00100000\n\nTIL j\n00000100\n00000101\n00000100\n00000101\n00000100\n00000101\n00000100\n00000101\n>\n00000101\n00000100\n00000101\n00000100\n00000101\n00000100\n00000101\n00000100\n\nTIL k\n00100000\n00100000\n10100000\n00100000\n10100000\n00100000\n10100000\n00100000\n>\n00100000\n10100000\n00100000\n10100000\n00100000\n10100000\n00100000\n10100000\n\nTIL l\n00000000\n01111110\n11000011\n10000001\n10000001\n10000001\n10000001\n10000001\n>\n01111110\n11000011\n10000001\n10000001\n10000001\n10000001\n10000001\n00000000\n\nTIL m\n00000000\n00000000\n11111111\n11111111\n00000000\n00000000\n11111111\n11111111\n>\n00000000\n11111111\n11111111\n00000000\n00000000\n11111111\n11111111\n00000000\n\nTIL n\n00001011\n00000010\n00001000\n00000001\n00001011\n00000010\n00001000\n00000001\n>\n00000010\n00001000\n00000001\n00001011\n00000010\n00001000\n00000001\n00001011\n\nTIL o\n11010000\n01000000\n00010000\n10000000\n11010000\n01000000\n00010000\n10000000\n>\n01000000\n00010000\n10000000\n11010000\n01000000\n00010000\n10000000\n11010000\n\nTIL p\n11010000\n01000000\n00010000\n10000000\n11010000\n01000000\n00010000\n11110000\n>\n01000000\n00010000\n10000000\n11010000\n01000000\n00010000\n11110000\n00000000\n\nTIL q\n00011000\n00011000\n00011000\n00011000\n00011000\n00011000\n00011000\n00011000\n\nTIL r\n00000000\n00000000\n00000000\n11111111\n11111111\n00000000\n00000000\n00000000\n\nTIL s\n00000000\n01111110\n01000010\n01000010\n01000010\n01000010\n01111110\n00000000\n\nTIL t\n00000000\n01100000\n01100000\n01100000\n01100000\n01100000\n00000000\n00100000\n>\n01100000\n01100000\n01100000\n01100000\n01100000\n00000000\n00100000\n00100000\n\nTIL u\n00000000\n00000111\n00000100\n00000100\n00000100\n00000111\n00000001\n00000101\n>\n00000111\n00000100\n00000100\n00000100\n00000111\n00000001\n00000101\n00000100\n\nTIL v\n00000000\n11111110\n01000010\n01000010\n01000010\n11111110\n11111110\n11111110\n>\n11111110\n01000010\n01000010\n01000010\n11111110\n11111110\n11111110\n00000000\n\nTIL w\n00000000\n00010000\n11110000\n11100000\n11100000\n11100000\n00000000\n00000000\n>\n00010000\n11110000\n11100000\n11100000\n11100000\n00000000\n00000000\n00000000\n\nTIL x\n00000000\n00001000\n00001111\n00000111\n00000111\n00000111\n00000000\n00000000\n>\n00001000\n00001111\n00000111\n00000111\n00000111\n00000000\n00000000\n00000000\n\nTIL y\n00000000\n00000000\n11111111\n11111111\n11111111\n00000111\n01010000\n01010000\n>\n00000000\n11111111\n11111111\n11111111\n00000111\n01010000\n01010000\n00001111\n\nTIL z\n00000000\n00000000\n11111111\n11111111\n11111111\n11100000\n00001010\n00001010\n>\n00000000\n11111111\n11111111\n11111111\n11100000\n00001010\n00001010\n11110000\n\nTIL 1a\n00000000\n11111101\n00000010\n11111010\n11111010\n11111010\n11111010\n00000101\n\nTIL 1b\n00000000\n10111111\n01000000\n01011111\n01011111\n01011111\n01011111\n10100000\n\nTIL 1c\n00011000\n00011000\n00011010\n00011001\n00011010\n00011001\n00011010\n00011000\n\nTIL 1d\n00000001\n00000011\n00000110\n00001111\n00011001\n00110110\n01111001\n11100100\n\nTIL 1e\n10000000\n11000000\n11100000\n10110000\n01011000\n00001100\n00010110\n00000011\n\nTIL 1f\n00000101\n00100001\n00000100\n00000000\n10001010\n00000000\n00010000\n00000001\n\nTIL 1g\n11110000\n10101000\n11000000\n01100000\n10000000\n00000000\n00000000\n00000000\n\nTIL 1h\n00000000\n00010000\n00010000\n01101100\n00010000\n00010000\n00000000\n00000000\n>\n00000000\n00000000\n00101000\n00010000\n00101000\n00000000\n00000000\n00000000\n\nTIL 1i\n00000000\n00000000\n00000000\n00000000\n00000000\n00010000\n00101000\n00010000\n>\n00000000\n00000000\n00000000\n00000000\n00000000\n00000000\n00010000\n00000000\n\nTIL 1j\n00000000\n00000000\n00001110\n00001111\n01111111\n11111111\n11111111\n10011101\n>\n00000000\n00000000\n00001100\n00111110\n00111111\n11111111\n11111111\n11001111\n\nTIL 1k\n00000000\n00000000\n00000000\n11000000\n11001100\n11111111\n11111111\n01111100\n>\n00000000\n00000000\n00000000\n11000000\n11101110\n11111111\n11111111\n00111110\n\nTIL 1l\n00001110\n01111110\n11111111\n11111111\n11111111\n11111111\n11111111\n01111100\n>\n00011100\n01111110\n01111111\n11111111\n11111111\n11111111\n11111110\n01100110\n\nTIL 1m\n00111000\n01111100\n01100000\n01011100\n01010100\n01011100\n00111000\n01000010\n\nTIL 1n\n00000000\n00000000\n10101010\n01010101\n10101010\n01010101\n10101010\n00000000\n\nTIL 1o\n00000111\n00000000\n00001111\n00001111\n00001111\n00011111\n00011111\n00011111\n\nTIL 1p\n00000000\n00000001\n00000001\n00000001\n00000011\n00000011\n00000011\n00000111\n\nTIL 1q\n00001111\n00100000\n00111111\n01111111\n01100111\n01100111\n11100111\n11111111\n\nTIL 1r\n11111111\n11111111\n00000000\n11111111\n10011111\n10011001\n10011001\n11111001\n\nTIL 1s\n11111110\n00000001\n11111110\n11100110\n11100110\n11100100\n11111100\n11111100\n\nTIL 1t\n11111000\n10011000\n10011000\n10010000\n11110000\n11110000\n11100000\n11100000\n\nTIL 1u\n11000000\n00011000\n11111000\n10010000\n10010000\n10010000\n11100000\n11100000\n\nTIL 1v\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n\nTIL 1w\n00000000\n00000000\n00000000\n00000000\n00011100\n01100010\n00000000\n00000000\n>\n00000000\n00000000\n00000000\n00000000\n00001100\n00110000\n00000000\n00000000\n\nTIL 1x\n00000000\n00000000\n00000000\n00000000\n11000011\n00111100\n10000010\n00010000\n>\n00000000\n00000000\n00000000\n00000000\n11110001\n00001110\n10000000\n00100001\n\nTIL 1y\n01000000\n00000000\n00000010\n00000000\n00100000\n00001000\n01000000\n00000010\n\nTIL 1z\n00000000\n00000000\n00000000\n00000000\n00000000\n00000000\n00000000\n00000000\n\nSPR A\n00000000\n00011000\n00011000\n00111100\n01111110\n10111101\n00100100\n00100100\n>\n00011000\n00011000\n00111100\n01111110\n10111101\n00100100\n00100100\n00000000\nPOS 0 2,5\n\nSPR a\n11011100\n10111110\n10110000\n00101110\n01101010\n01101110\n01101000\n00110001\n>\n11011100\n10111110\n10110000\n00101110\n01101010\n01101110\n01101100\n00110001\nDLG SPR_1\nPOS 1 11,2\n\nSPR b\n01111011\n10011101\n10101101\n10001000\n01010110\n01110110\n01101110\n00001110\n>\n01111011\n11001101\n10010101\n10001000\n01010110\n01110110\n01101110\n00001110\nDLG SPR_2\nPOS 1 10,2\n\nSPR c\n01111000\n10011100\n10101100\n10001000\n01011000\n01111100\n11111110\n00000000\n>\n01111000\n11001100\n10010100\n10001000\n01011000\n01111100\n11111110\n00000000\nDLG SPR_3\nPOS 3 2,5\n\nSPR d\n01011100\n10111110\n10110000\n00101110\n01101010\n01101110\n01101000\n00110001\n>\n01011100\n10111110\n10110000\n00101110\n01101010\n01101110\n01101100\n00110001\nDLG SPR_4\nPOS 4 2,5\n\nSPR e\n00011000\n00111100\n01111110\n00100100\n00100110\n00011001\n00010001\n01100011\n>\n00011000\n00111100\n01111110\n00100100\n00100110\n00011001\n01010001\n00100011\nDLG SPR_5\nPOS 1 14,5\n\nSPR f\n00011000\n00111100\n01111110\n00100100\n00100110\n00011001\n00010001\n01100011\n>\n00011000\n00111100\n01111110\n00100100\n00100110\n00011001\n01010001\n00100011\nDLG SPR_6\nPOS 5 2,5\n\nSPR g\n00000000\n00110110\n01111010\n00011110\n00001110\n00111110\n00000110\n00011110\n>\n00000110\n00111010\n01111110\n00000110\n00111110\n00000110\n00011110\n00111110\nDLG SPR_7\nPOS 1 10,5\n\nSPR h\n00000000\n00110110\n01111010\n00011110\n00001110\n00111110\n00000110\n00011110\n>\n00000110\n00111010\n01111110\n00000110\n00111110\n00000110\n00011110\n00000000\nDLG SPR_8\nPOS 6 2,5\n\nDLG SPR_0\nhello\n\nDLG SPR_1\nto stoop so low into the dirt... it's almost claustrophobic\n\nDLG SPR_2\nthe stars... when will they dance again?\n\nDLG SPR_4\nwe lived atop a stone colossus. always climbing higher, never looking back. before long there was no one left who remembered the foundations, much less had seen them\n\nDLG SPR_5\noh... is the tide out again?\n\nDLG SPR_6\nwe couldn't make peace with the ebb and flow and sunk deeper into extremities. will we rise again?\n\nDLG SPR_7\nahhh to see the end one more time...\n\nDLG SPR_8\nit's one thing to drive yourself to the edge of the world, but another thing entirely to pass over it. what else could we do but drown?\n\nDLG SPR_3\nfor centuries we watched the stars, dreaming we could one day look down again -- but the mountains are no place to thrive\n\nEND 0\n\n\nEND undefined\nwho will remember?\n\n";
function startExportedGame() {
	attachCanvas( document.getElementById("game") );
	load_game(exportedGameData);
}
</script>

<script>
function Font() {


this.getData = function() {
	return fontdata;
}

var charSize = 6 * 8;
this.getChar = function(char) {
	var startIndex = char.charCodeAt(0) * charSize;
	return fontdata.slice( startIndex, startIndex + charSize );
}

var fontdata = [
		/* num: 0 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 1 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,0,1,1,
		0,1,0,0,0,1,
		0,1,0,1,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 2 */
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,1,0,1,0,1,
		0,1,1,1,1,1,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 3 */
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 4 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/*0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,1,0,1,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,*/
		/* num: 5 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 6 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 7 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 8 */
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,0,0,1,1,
		1,1,0,0,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 9 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 10 */
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,0,0,0,0,1,
		1,0,1,1,0,1,
		1,0,1,1,0,1,
		1,0,0,0,0,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 11 */
		0,0,0,0,0,0,
		0,0,0,1,1,1,
		0,0,0,0,1,1,
		0,0,1,1,0,1,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 12 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 13 */
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,1,0,1,
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		0,1,1,1,0,0,
		0,1,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 14 */
		0,0,0,0,1,1,
		0,0,1,1,0,1,
		0,0,1,0,1,1,
		0,0,1,1,0,1,
		0,0,1,0,1,1,
		0,1,1,0,1,1,
		0,1,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 15 */
		0,0,0,0,0,0,
		0,1,0,1,0,1,
		0,0,1,1,1,0,
		0,1,1,0,1,1,
		0,0,1,1,1,0,
		0,1,0,1,0,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 16 */
		0,0,1,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,1,0,
		0,0,1,1,1,1,
		0,0,1,1,1,0,
		0,0,1,1,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 17 */
		0,0,0,0,1,0,
		0,0,0,1,1,0,
		0,0,1,1,1,0,
		0,1,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,1,0,
		0,0,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 18 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 19 */
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 20 */
		0,0,1,1,1,1,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,0,1,1,0,1,
		0,0,0,1,0,1,
		0,0,0,1,0,1,
		0,0,0,1,0,1,
		0,0,0,0,0,0,
		/* num: 21 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,1,1,0,0,
		0,0,1,0,1,0,
		0,0,0,1,1,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 22 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 23 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		/* num: 24 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 25 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 26 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,1,1,1,1,1,
		0,0,0,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 27 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		0,1,1,1,1,1,
		0,0,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 28 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 29 */
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,1,1,1,1,1,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 30 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 31 */
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 32 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 33 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 34 */
		0,1,1,0,1,1,
		0,1,1,0,1,1,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 35 */
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,1,1,1,1,1,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,1,1,1,1,1,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 36 */
		0,0,1,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,0,0,
		0,0,0,0,1,0,
		0,1,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 37 */
		0,1,1,0,0,1,
		0,1,1,0,0,1,
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,1,0,0,1,1,
		0,1,0,0,1,1,
		0,0,0,0,0,0,
		/* num: 38 */
		0,0,1,0,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,0,1,0,0,0,
		0,1,0,1,0,1,
		0,1,0,0,1,0,
		0,0,1,1,0,1,
		0,0,0,0,0,0,
		/* num: 39 */
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 40 */
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 41 */
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 42 */
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 43 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 44 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,1,0,0,0,
		/* num: 45 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 46 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 47 */
		0,0,0,0,0,0,
		0,0,0,0,0,1,
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 48 ZERO!!!!*/
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,1,1,
		0,1,0,1,0,1,
		0,1,1,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 49 */
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 50 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,0,0,0,1,
		0,0,0,1,1,0,
		0,0,1,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 51 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 52 */
		0,0,0,0,1,0,
		0,0,0,1,1,0,
		0,0,1,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,1,1,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 53 */
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 54 */
		0,0,0,1,1,0,
		0,0,1,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 55 */
		0,1,1,1,1,1,
		0,0,0,0,0,1,
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 56 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 57 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,1,
		0,0,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 58 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 59 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,1,0,0,0,
		/* num: 60 */
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,1,0,0,0,0,
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 61 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 62 */
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,1,0,
		0,0,0,0,0,1,
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 63 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,0,0,0,1,
		0,0,0,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 64 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,1,1,1,
		0,1,0,1,0,1,
		0,1,0,1,1,1,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 65 Start of Capital Letters*/
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 66 */
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 67 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 68 */
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 69 */
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 70 */
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 71 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,1,0,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 72 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 73 */
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 74 */
		0,0,0,0,0,1,
		0,0,0,0,0,1,
		0,0,0,0,0,1,
		0,0,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 75 */
		0,1,0,0,0,1,
		0,1,0,0,1,0,
		0,1,0,1,0,0,
		0,1,1,0,0,0,
		0,1,0,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 76 */
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 77 */
		0,1,0,0,0,1,
		0,1,1,0,1,1,
		0,1,0,1,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 78 */
		0,1,0,0,0,1,
		0,1,1,0,0,1,
		0,1,0,1,0,1,
		0,1,0,0,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 79 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 80 */
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 81 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,1,0,1,
		0,1,0,0,1,0,
		0,0,1,1,0,1,
		0,0,0,0,0,0,
		/* num: 82 */
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 83 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 84 */
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 85 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 86 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 87 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 88 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 89 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 90 */
		0,1,1,1,1,0,
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 91 */
		0,0,1,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 92 */
		0,0,0,0,0,0,
		0,1,0,0,0,0,
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,1,0,
		0,0,0,0,0,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 93 */
		0,0,1,1,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 94 */
		0,0,0,1,0,0,
		0,0,1,0,1,0,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 95 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		/* num: 96 */
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 97 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 98 */
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 99 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 100 */
		0,0,0,0,0,1,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 101 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 102 */
		0,0,0,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,1,1,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 103 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,1,
		0,0,1,1,1,0,
		/* num: 104 */
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 105 */
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 106 */
		0,0,0,0,1,0,
		0,0,0,0,0,0,
		0,0,0,1,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		/* num: 107 */
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,1,0,0,
		0,1,1,0,0,0,
		0,1,0,1,0,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 108 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 109 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,0,1,0,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 110 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 111 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 112 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		/* num: 113 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,1,
		/* num: 114 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,1,1,0,
		0,0,1,0,0,1,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,1,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 115 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 116 */
		0,0,0,0,0,0,
		0,0,1,0,0,0,
		0,1,1,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 117 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 118 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 119 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,1,0,1,
		0,1,1,1,1,1,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 120 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 121 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,1,1,0,0,0,
		/* num: 122 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,1,0,
		0,0,1,1,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 123 */
		0,0,0,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,1,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 124 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 125 */
		0,0,1,1,0,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,1,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 126 */
		0,0,1,0,1,0,
		0,1,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 127 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,1,0,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 128 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		/* num: 129 */
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 130 */
		0,0,0,0,1,1,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 131 */
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 132 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 133 */
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 134 */
		0,0,1,1,1,0,
		0,0,1,0,1,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 135 */
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		/* num: 136 */
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 137 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 138 */
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 139 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 140 */
		0,0,0,1,0,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 141 */
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 142 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,0,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 143 */
		0,0,1,1,1,0,
		0,0,1,0,1,0,
		0,0,1,1,1,0,
		0,1,1,0,1,1,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 144 */
		0,0,0,0,1,1,
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 145 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,1,0,1,
		0,1,1,1,1,1,
		0,1,0,1,0,0,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 146 */
		0,0,1,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,1,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,1,1,
		0,0,0,0,0,0,
		/* num: 147 */
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 148 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 149 */
		0,1,1,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 150 */
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 151 */
		0,1,1,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 152 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,1,1,0,0,0,
		/* num: 153 */
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 154 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 155 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 156 */
		0,0,0,1,1,0,
		0,0,1,0,0,1,
		0,0,1,0,0,0,
		0,1,1,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,1,
		0,1,0,1,1,1,
		0,0,0,0,0,0,
		/* num: 157 */
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 158 */
		0,1,1,0,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,1,0,1,0,
		0,1,0,1,1,1,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 159 */
		0,0,0,0,1,0,
		0,0,0,1,0,1,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,1,0,1,0,0,
		0,0,1,0,0,0,
		/* num: 160 */
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 161 */
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 162 */
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 163 */
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 164 */
		0,0,1,0,1,0,
		0,1,0,1,0,0,
		0,0,0,0,0,0,
		0,1,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 165 */
		0,0,1,0,1,0,
		0,1,0,1,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,1,0,1,0,
		0,1,0,1,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 166 */
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 167 */
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 168 */
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 169 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 170 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,1,
		0,0,0,0,0,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 171 */
		0,1,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,1,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,0,0,1,0,
		0,0,0,1,1,1,
		0,0,0,0,0,0,
		/* num: 172 */
		0,1,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,1,0,0,
		0,0,1,0,1,1,
		0,1,0,1,0,1,
		0,0,0,1,1,1,
		0,0,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 173 */
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 174 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,0,0,1,
		0,1,0,0,1,0,
		0,0,1,0,0,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 175 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,0,1,0,0,1,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 176 */
		0,1,0,1,0,1,
		0,0,0,0,0,0,
		1,0,1,0,1,0,
		0,0,0,0,0,0,
		0,1,0,1,0,1,
		0,0,0,0,0,0,
		1,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 177 */
		0,1,0,1,0,1,
		1,0,1,0,1,0,
		0,1,0,1,0,1,
		1,0,1,0,1,0,
		0,1,0,1,0,1,
		1,0,1,0,1,0,
		0,1,0,1,0,1,
		1,0,1,0,1,0,
		/* num: 178 */
		1,0,1,0,1,0,
		1,1,1,1,1,1,
		0,1,0,1,0,1,
		1,1,1,1,1,1,
		1,0,1,0,1,0,
		1,1,1,1,1,1,
		0,1,0,1,0,1,
		1,1,1,1,1,1,
		/* num: 179 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 180 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 181 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		/* num: 182 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		1,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 183 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 184 */
		0,0,0,0,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 185 */
		0,1,0,1,0,0,
		1,1,0,1,0,0,
		0,0,0,1,0,0,
		1,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 186 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 187 */
		0,0,0,0,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		1,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 188 */
		0,1,0,1,0,0,
		1,1,0,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 189 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 190 */
		0,0,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 191 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 192 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 193 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 194 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 195 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 196 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 197 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 198 */
		0,0,0,1,0,0,
		0,0,0,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 199 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 200 */
		0,1,0,1,0,0,
		0,1,0,1,1,1,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 201 */
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,0,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 202 */
		0,1,0,1,0,0,
		1,1,0,1,1,1,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 203 */
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		1,1,0,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 204 */
		0,1,0,1,0,0,
		0,1,0,1,1,1,
		0,1,0,0,0,0,
		0,1,0,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 205 */
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 206 */
		0,1,0,1,0,0,
		1,1,0,1,1,1,
		0,0,0,0,0,0,
		1,1,0,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 207 */
		0,0,0,1,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 208 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 209 */
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 210 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 211 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 212 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		/* num: 213 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 214 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 215 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 216 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 217 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 218 */
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 219 */
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 220 */
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		/* num: 221 */
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		/* num: 222 */
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		/* num: 223 */
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		/* num: 224 */
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		/* num: 225 */
		0,0,0,0,0,0,
		0,1,1,1,0,0,
		0,1,0,0,1,0,
		0,1,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,0,0,
		0,1,0,0,0,0,
		/* num: 226 */
		0,1,1,1,1,0,
		0,1,0,0,1,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 227 */
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 228 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 229 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,1,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 230 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		/* num: 231 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,1,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 232 */
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 233 */
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 234 */
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,1,1,0,1,1,
		0,0,0,0,0,0,
		/* num: 235 */
		0,0,1,1,0,0,
		0,1,0,0,0,0,
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 236 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 237 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 238 */
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 239 */
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 240 */
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 241 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 242 */
		0,1,0,0,0,0,
		0,0,1,1,0,0,
		0,0,0,0,1,0,
		0,0,1,1,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 243 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,0,0,0,
		1,0,0,1,1,0,
		1,0,0,0,0,1,
		1,0,0,0,0,0,
		1,1,1,1,1,1,
		/* num: 244 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,1,1,1,
		0,1,1,0,0,1,
		1,0,0,0,0,1,
		0,0,0,0,0,1,
		1,1,1,1,1,1,
		/* num: 245 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,1,0,1,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 246 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 247 */
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		/* num: 248 */
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		/* num: 249 */
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		/* num: 250 */
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		/* num: 251 */
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		/* num: 252 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 253 */
		0,1,1,0,0,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,1,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 254 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		1,1,0,0,1,0,
		1,1,0,0,1,1,
		1,1,1,1,1,0,
		0,0,1,1,1,1,
		/* num: 255 */
		0,1,0,0,1,0,
		1,1,1,1,1,1,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		1,1,1,1,1,1,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0
];


} // Font()
</script>

<script>
/* QUESTIONS
shallow dialog blocks? ''' dialog block '''
or nestable dialog blocks?
	/"
		dialog block 
		{
			code block
			/"dialog"/
			code
		}
		dialog
	"/

significant whitespace?

{code} is a single expression? or a block?
{exp}
{exp}
vs
{
	exp
	exp
}

separate syntax for code block vs expression? e.g. double braces

return value from expression/code block?

{case
	* condition
		result
	* condition
		result
}
vs
{
if condition
	result
elseif condition
	result
}

{choice
	* choice1
		result
	* choice2
		result
}
vs
{
* choice1
	result
* choice2
	result
}
*/

/* NEW PARSE TODO
- attach dialog commands to dialog renderer
- parse code
- parse functions
- parse special functions: case, choice?
- formatting / text effects
- replace old parsing code
- expressions parsing
- function library
- variable library
- nail down syntax of case statements, multline code, whitespace, etc.
- replace root node with block (of either type)
	- should blocks be "type:block" "kind:dialog"??
	- or do they even need to be identified???

- scriptEnvironment -> fills -> dialogBuffer
- dialogRenderer -> draws -> dialogBuffer

- is code called immediately? or after dialog finishes rendering?
- IDEA: use special "script characters" injected into dialog buffer to launch scripts and effects during dialog
	- what about scripts with no dialog? should they depend on the buffer?

- ScriptParser -> outputs -> ScriptTree
- ScriptEnvironment -> runs -> ScriptTree
- environment needs a way to wait on dialog buffer (handler)
*/

/*
function
	name
	parameters
variable
	type (needed?)
block
	type
*/

function Script() {

var Environment = function() {
	var dialogBuffer = null;
	this.SetBuffer = function(buffer) { dialogBuffer = buffer; };

	// TODO
}


/* NODES */
function AddCreate(obj, func) {
	return Object.assign( obj, {
		Create : function(param) {
			return Object.assign( Object.create(this), new func( param ) );
		}
	});
}

var TreeRelationship = {
	parent : null,
	children : [],
	AddChild : function(node) {
		this.children.push( node );
		node.parent = this;
	}
};

var BlockMode = {
	Dialog : "dialog",
	Code : "code"
};

var BlockNode = {
	type : "block",
	Create : function(mode) {
		var block = Object.create( BlockNode );
		block.mode = mode;
		return block;
	}
}
Object.assign( BlockNode, TreeRelationship );
AddCreate( BlockNode, 
	function(param) {
		this.mode = param.mode;
	}
);

function Create(obj, init) {
	var obj = Object.create(obj);
	Object.assign( obj, init() );
	return obj;
}

var FuncNode = {
	type : "function"
}
Object.assign( FuncNode, TreeRelationship );
AddCreate( FuncNode,
	function(param){
		for(name in param) {
			this[name] = param[name];
		}
	}
);


var Parser = function() {
	var Sym = {
		DialogOpen : "/\"",
		DialogClose : "\"/",
		CodeOpen : "{",
		CodeClose : "}",
		Linebreak : "\n", // just call it "break" ?
		Separator : ":",
		List : "*"
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// console.log(str);
			str = "" + str; // hack to turn single chars into strings
			// console.log(str);
			// console.log(str.length);
			for(var j = 0; j < str.length; j++) {
				if( i + j >= sourceStr.length )
					return false;
				else if( str[j] != sourceStr[i+j] )
					return false;
			}
			return true;
		}
		this.ConsumeBlock = function( open, close ) {
			var startIndex = i;

			var matchCount = 0;
			if( this.MatchAhead( open ) ) {
				matchCount++;
				this.Step( open.length );
			}

			while( matchCount > 0 && !this.Done() ) {
				if( this.MatchAhead( close ) ) {
					matchCount--;
					this.Step( close.length );
				}
				else if( this.MatchAhead( open ) ) {
					matchCount++;
					this.Step( open.length );
				}
				else {
					this.Step();
				}
			}

			// console.log("!!! " + startIndex + " " + i);

			return sourceStr.slice( startIndex + open.length, i - close.length );
		}

		// var saveIndex = 0;
		// this.Save = function() { saveIndex = i; };
		// this.Restore = function() { i = saveIndex; };
	};

	this.Parse = function(scriptStr) {
		var state = new ParserState( null /*rootNode*/, str );

		if( state.MatchAhead(Sym.DialogOpen) ) {
			state = ParseDialogBlock( state );
		}
		else if( state.MatchAhead(Sym.CodeOpen) ) {
			state = ParseCodeBlock( state );
		}

		// while( !state.Done() ) {
		// 	// console.log( state.Char() );
		// 	if( state.MatchAhead(Sym.DialogOpen) ) {
		// 		state = ParseDialogBlock( state );
		// 	}
		// 	else if( state.MatchAhead(Sym.CodeOpen) ) {
		// 		state = ParseCodeBlock( state );
		// 	}
		// 	else {
		// 		state.Step();
		// 	}
		// }

		// return state.rootNode;
	};

	function ParseDialog(state) {
		var text = "";
		var lineCount = 0;
		var addTextNode = function() {
			if (text.length > 0) {
				var textNode = {
					type : "text", // names: "say" instead? or this that a "function"
					parent : state.curNode,
					// children : [], // can't have children?
					text : text
				};
				state.curNode.children.push( textNode );

				text = "";
				lineCount++;
			}
		}

		while ( !state.Done() ) {

			if( state.MatchAhead(Sym.DialogOpen) ) {
				addTextNode();
				state = ParseDialogBlock( state ); // These can be nested
			}
			else if( state.MatchAhead(Sym.CodeOpen) ) {
				addTextNode();
				state = ParseCodeBlock( state );
			}
			else {
				if ( state.MatchAhead(Sym.Linebreak) ) {
					addTextNode();

					// NOTE: don't add linebreaks at the very beginning or end of the block
					// TODO: also skip ones right after a code block??
					var shouldAddLineBreak = (lineCount > 0) && ((state.Count() - state.Index()) > 1);
					if( shouldAddLineBreak ) {
						var linebreakNode = {
							type : "linebreak",
							parent : state.curNode
						}
						state.curNode.children.push( linebreakNode );	
					}

					text = "";
				}
				else {
					text += state.Char();
				}
				state.Step();
			}

		}
		addTextNode();

		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );
		// console.log("DIALOG " + dialogStr);

		var dialogBlockNode = {
			type : "dialog", // names: text vs dialog is bad
			parent : null,
			children : []
		};

		var dialogState = new ParserState( dialogBlockNode, dialogStr );
		dialogState = ParseDialog( dialogState );

		dialogState.rootNode.parent = state.curNode; // TODO : make this a method
		state.curNode.children.push( dialogState.rootNode );

		return state;
	}

	function ParseCode(state) {
		// TODO
		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
		// console.log("CODE " + codeStr);

		var codeBlockNode = {
			type : "code",
			parent : null,
			children : [],
			content : codeStr
		};

		var codeState = new ParserState( codeBlockNode, codeStr );
		codeState = ParseCode( codeState );

		codeState.rootNode.parent = state.curNode; // TODO : make this a method
		state.curNode.children.push( codeState.rootNode );

		// eat next linebreak
		if( state.MatchAhead( Sym.Linebreak ) )
			state.Step();

		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {
	var textboxInfo = {
		img : null,
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
	};
	
	var font = new Font();

	var context = null;
	this.AttachContext = function(c) {
		context = c;
	};

	this.ClearTextbox = function() {
		if(context == null) return;
		textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		if(context == null) return;
		if (isCentered) {
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
		}
		else if (player().y < mapsize/2) {
			//bottom
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, (height-textboxInfo.bottom-textboxInfo.height)*scale);
		}
		else {
			//top
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, textboxInfo.top*scale);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];
	this.DrawNextArrow = function() {
		// console.log("draw arrow!");
		var top = (textboxInfo.height-5) * scale;
		var left = (textboxInfo.width-(5+4)) * scale;
		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < scale; sy++) {
						for (var sx = 0; sx < scale; sx++) {
							var pxl = 4 * ( ((top+(y*scale)+sy) * (textboxInfo.width*scale)) + (left+(x*scale)+sx) );
							textboxInfo.img.data[pxl+0] = 255;
							textboxInfo.img.data[pxl+1] = 255;
							textboxInfo.img.data[pxl+2] = 255;
							textboxInfo.img.data[pxl+3] = 255;
						}
					}
				}
			}
		}
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col) {
		char.offset = {x:0, y:0};
		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);
		var charData = font.getChar( char.char );
		var top = (4 * scale) + (row * 2 * scale) + (row * 8 * text_scale) + Math.floor( char.offset.y );
		var left = (4 * scale) + (col * 6 * text_scale) + Math.floor( char.offset.x );
		for (var y = 0; y < 8; y++) {
			for (var x = 0; x < 6; x++) {
				var i = (y * 6) + x;
				if ( charData[i] == 1 ) {

					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
							textboxInfo.img.data[pxl+0] = char.color.r;
							textboxInfo.img.data[pxl+1] = char.color.g;
							textboxInfo.img.data[pxl+2] = char.color.b;
							textboxInfo.img.data[pxl+3] = char.color.a;
						}
					}

					
				}
			}
		}
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer,dt) { // TODO move out of the buffer?? (into say a dialog box renderer)
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar( this.DrawChar );

		if( buffer.CanContinue() )
			this.DrawNextArrow();

		this.DrawTextbox();

		if( buffer.DidPageFinishThisFrame() && onPageFinish != null )
			onPageFinish();
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var tree = null; // holds dialog and command nodes in a tree structure

	/* NEW SCRIPT STUFF */
	var scriptTree = null;
	
	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			console.log(charCount);
			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char)
					handler( char, i /*rowIndex*/, j /*colIndex*/ );
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;
	};
	
	var onExit = null;
	this.Start = function(dialogSourceStr,exitHandler) {
		this.Reset();

		onExit = exitHandler;

		if( featureNewScript ) {
			// scriptTree = script.NewParse( dialogSourceStr );
			console.log( scriptTree );
		}
		else {
			var dml = new DialogMarkup();
			tree = dml.Parse( dialogSourceStr );
			tree.SetBuffer( this );
			tree.Traverse();
		}
	};

	this.TryFillBuffer = function() {
		// after drawing the last character in the current dialog buffer, do the next dialog tree traversal
		if( pageIndex === this.CurPageCount()-1 
			&& rowIndex === this.CurRowCount()-1 
			&& charIndex === this.CurCharCount()-1 )
		{
			if( featureNewScript ) {
				// TODO
			}
			else {
				tree.Traverse();	
			}
		}
	};

	this.DoNextChar = function() {
		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;
		}

		this.TryFillBuffer();
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		if(onExit != null)
			onExit();
	}

	this.Continue = function() {
		console.log("CONTINUE");
		this.TryFillBuffer();
		if (pageIndex + 1 < this.CurPageCount()) {
			//start next page
			this.FlipPage();
		}
		else {
			//end dialog mode
			this.EndDialog();
		}
	};

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(char,nodeTrail) {
		this.char = char;
		this.nodeTrail = nodeTrail;

		this.color = { r:255, g:255, b:255, a:255 };
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)
		this.row = 0;
		this.col = 0;
		this.SetPosition = function(row,col) {
			this.row = row;
			this.col = col;
		};

		this.ApplyEffects = function(time) {
			for(var i = 0; i < this.nodeTrail.length; i++) {
				var node = this.nodeTrail[i];
				node.DoEffect(this,time);
			}
		}
	};

	function AddWordToCharArray(charArray,word,nodeTrail) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogChar( word[i], nodeTrail ) );
		}
		return charArray;
	}

	var charsPerRow = 32;
	this.AddText = function(textStr,nodeTrail) { // TODO : change "nodeTrail" to "effectList"
		//process dialog so it's easier to display
		var words = textStr.split(" ");

		var curPageIndex = this.CurPageCount() - 1;
		var curRowIndex = this.CurRowCount() - 1;
		var curRowArr = this.CurRow();

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			var wordLength = word.length + ((i == 0) ? 0 : 1);
			if (curRowArr.length + wordLength <= charsPerRow) {
				//stay on same row
				var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
				curRowArr = AddWordToCharArray( curRowArr, wordWithPrecedingSpace, nodeTrail );
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer[ curPageIndex ].push( [] );
				curRowIndex++;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, nodeTrail );
			}
			else {
				//start next page
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer.push( [] );
				curPageIndex++;
				buffer[ curPageIndex ].push( [] );
				curRowIndex = 0;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, nodeTrail );
			}
		}

		//finish up 
		if( curRowArr.length > 0 ) {
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
		}

		//destroy any empty stuff
		var lastPage = buffer[ buffer.length-1 ];
		var lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length == 0 )
			lastPage.splice( lastPage.length-1, 1 );
		if( lastPage.length == 0 )
			buffer.splice( buffer.length-1, 1 );
	};

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };
};

var DialogNode = function() {
	this.type = "";
	this.children = [];
	this.attributes = {};
	this.parent = null;
	this.buffer = null; // DialogBuffer reference
	this.AddChild = function(node) {
		this.children.push( node );
		node.parent = this;
	};
	this.AddAttribute = function(name,value) {
		// console.log("ADD ATTR " + name);
		this.attributes[name] = { name:name, value:value };
	};
	this.canHaveChildren = false;

	this.OnCloseTag = function() {};

	var traverseIndex = -1;
	this.Visit = function() {
		console.log("node!! " + this.type);
		return true;
	};
	this.Traverse = function() {
		// console.log("TRAVERSE!!");
		var doContinue = true;
		if (traverseIndex < 0) { // traverseIndex == -1 means visit self
			doContinue = this.Visit();
			traverseIndex++;
		}
		while( doContinue && traverseIndex < this.children.length ) {
			// console.log(traverseIndex);
			doContinue = this.children[ traverseIndex ].Traverse();
			if(doContinue)
				traverseIndex++;
		}
		return doContinue;
	};
	this.Trail = function() {
		var trail = [this];
		if(this.parent != null)
			trail = this.parent.Trail().concat( trail );
		return trail;
	};
	this.SetBuffer = function(buffer) {
		this.buffer = buffer;
		for(var i = 0; i < this.children.length; i++) {
			this.children[i].SetBuffer( buffer );
		}
	};
	this.DoEffect = function(char) {
		// console.log("DO EFFECT " + this.type + " " + char.char);
	};
};

var DialogNodeFactory = {
	baseConstructor : DialogNode,
	typeConstructors : {},
	AddType : function(constructor) {
		var node = new constructor();
		this.typeConstructors[ node.type ] = constructor;
	},
	Create : function(type) {
		var node = Object.assign( new this.baseConstructor(), new this.typeConstructors[type]() );
		return node;
	}
};

var RootNode = function() {
	this.type = "root";
	this.canHaveChildren = true;
};
DialogNodeFactory.AddType( RootNode );

var TextNode = function() {
	this.type = "text";
	this.text = "";
	this.Visit = function() {
		console.log(this.text);
		if(this.buffer != null)
			this.buffer.AddText( this.text, this.Trail() );
		return false;
	};
};
DialogNodeFactory.AddType( TextNode );

var IfNode = function() {
	this.type = "if";
	this.canHaveChildren = true;

	this.branches = [];
	this.OnCloseTag = function() {
		console.log("CLOSE IF");
		var curBranch = {
			node : this,
			children : []
		};

		for (var i = 0; i < this.children.length; i++) {
			var child = this.children[i];
			if (child.type === "elseif" || child.type === "else") {
				// save current branch
				this.branches.push( curBranch );
				// start new branch
				curBranch = {
					node : child,
					children : []
				};
			}
			else {
				// add child to branch
				curBranch.children.push( child );
			}
		}

		// save current branch
		this.branches.push( curBranch );
	};

	this.CheckCondition = function() {
		if( this.attributes["item"] ) {
			var itemId = this.attributes["item"].value;
			return player().inventory[itemId] && player().inventory[itemId] > 0;
		}
		return false;
	};

	this.Visit = function() {
		this.children = [];
		for (var i = 0; i < this.branches.length; i++) {
			var b = this.branches[i];
			if( b.node.CheckCondition() == true ) {
				this.children = b.children;
				break;
			}
		}
		return true;
	}
};
DialogNodeFactory.AddType( IfNode );

var ElseIfNode = function() {
	this.type = "elseif";
	this.CheckCondition = function() {
		if( this.attributes["item"] ) {
			var itemId = this.attributes["item"].value;
			return player().inventory[itemId] && player().inventory[itemId] > 0;
		}
		return false;
	};
};
DialogNodeFactory.AddType( ElseIfNode );

var ElseNode = function() {
	this.type = "else";
	this.CheckCondition = function() {
		return true;
	};
};
DialogNodeFactory.AddType( ElseNode );

var ColorNode = function() {
	this.type = "color";
	this.canHaveChildren = true;
	this.DoEffect = function(char) {
		// console.log("DO EFFECT COLOR");
		// console.log(this.attributes);
		if (this.attributes["index"] != null) {
			var pal = palette[ curPal() ];
			var color = pal[ parseInt( this.attributes["index"].value ) ];
			// console.log(color);
			char.color.r = color[0];
			char.color.g = color[1];
			char.color.b = color[2];
			char.color.a = 255;
		}
	}
};
DialogNodeFactory.AddType( ColorNode );

var RainbowNode = function() {
	this.type = "rainbow";
	this.canHaveChildren = true;
	this.DoEffect = function(char,time) {
		var h = Math.abs( Math.sin( (time / 600) - (char.col / 8) ) );
		var rgb = hslToRgb( h, 1, 0.5 );
		char.color.r = rgb[0];
		char.color.g = rgb[1];
		char.color.b = rgb[2];
		char.color.a = 255;
	}
};
DialogNodeFactory.AddType( RainbowNode );

var WavyNode = function() {
	this.type = "wavy";
	this.canHaveChildren = true;
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * 4;
	}
};
DialogNodeFactory.AddType( WavyNode );

var ShakyNode = function() {
	this.type = "shaky";
	this.canHaveChildren = true;

	function disturb(func,time,offset,mult1,mult2) {
		return func( (time * mult1) - (offset * mult2) );
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 3
						* disturb(Math.sin,time,char.col,0.1,0.5)
						* disturb(Math.cos,time,char.col,0.3,0.2)
						* disturb(Math.sin,time,char.row,2.0,1.0);
		char.offset.x += 3
						* disturb(Math.cos,time,char.row,0.1,1.0)
						* disturb(Math.sin,time,char.col,3.0,0.7)
						* disturb(Math.cos,time,char.col,0.2,0.3);
	}
};
DialogNodeFactory.AddType( ShakyNode );


// source : https://gist.github.com/mjackson/5311256
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ r * 255, g * 255, b * 255 ];
}

function DialogMarkup() {
	this.Parse = function(dialogStr) {
		var parsingState = {
			rootNode : DialogNodeFactory.Create("root"),
			curParentNode : null,
			src: dialogStr,
			i: 0,
			Done : function() {
				return parsingState.i >= parsingState.src.length;
			},
			Char : function() {
				return parsingState.src[ parsingState.i ];
			},
			Increment : function() {
				parsingState.i++;
			}
		};
		parsingState.curParentNode = parsingState.rootNode;
		// console.log(parsingState);
		while(!parsingState.Done()) {
			var char = parsingState.Char();
			// console.log(char);
			if( featureNewDialog ) {
				if(char === "<"){
					parsingState = parseTag(parsingState)
				}
				else {
					parsingState = parseText(parsingState);
				}
			}
			else {
				// only parse text
				parsingState = parseText(parsingState);
			}
			// parsingState.Increment();
		}
		console.log( parsingState.rootNode );
		return parsingState.rootNode;
	}
	function parseTag(parsingState) {
		// console.log("TAG");
		var tagStr = "";
		while(!parsingState.Done() && parsingState.Char() != ">") {
			tagStr += parsingState.Char();
			parsingState.Increment();
		}

		if(parsingState.Done())
			return parsingState; // exit if done
		
		//add final angle bracket
		tagStr += parsingState.Char();
		parsingState.Increment();
		// console.log(tagStr);

		//cut off angle brackets
		tagStr = tagStr.slice(1,tagStr.length-1);

		// console.log(tagStr);

		//get node type
		var i = 0;
		var type = "";
		while(tagStr[i] != " " && i < tagStr.length) {
			type += tagStr[i];
			i++;
		}
		tagStr = tagStr.slice(i);
		// console.log(type);
		// console.log(tagStr);

		console.log(type);
		if(type[0] === "/") {
			// this is the end of a tag
			type = type.slice(1);
			console.log("tag end!!!");
			console.log(type);

			if( parsingState.curParentNode.type === type && parsingState.curParentNode.parent != null )
			{
				parsingState.curParentNode.OnCloseTag();
				parsingState.curParentNode = parsingState.curParentNode.parent;
			}

			return parsingState;
		}

		var tagNode = DialogNodeFactory.Create(type);

		// console.log(tagStr);
		var attributeRegex = /([a-zA-Z]+)=\"([a-zA-Z0-9\s]+)\"/g;
		var attributeMatch = attributeRegex.exec( tagStr );
		// console.log(attributeMatch);
		while( attributeMatch != null ) {
			tagNode.AddAttribute( attributeMatch[1] /*name*/, attributeMatch[2] /*value*/ );
			attributeMatch = attributeRegex.exec( tagStr );
		}

		// console.log( tagNode );

		parsingState.curParentNode.AddChild( tagNode );

		if( tagNode.canHaveChildren )
			parsingState.curParentNode = tagNode;

		return parsingState;
	}
	function parseText(parsingState) {
		//TODO
		// console.log("TEXT");
		var textStr = "";
		if( featureNewDialog ) {
			while(!parsingState.Done() && parsingState.Char() != "<") {
				textStr += parsingState.Char();
				parsingState.Increment();
			}
		}
		else {
			while(!parsingState.Done()) {
				textStr += parsingState.Char();
				parsingState.Increment();
			}
		}
		// console.log(textStr);
		var textNode = DialogNodeFactory.Create("text");
		textNode.text = textStr;
		parsingState.curParentNode.AddChild( textNode );
		return parsingState;
	}
}

} // Dialog()
</script>

<script>
var xhr;
var canvas;
var context;
var ctx;

var title = "";
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = {
	"0" : [[0,0,0],[255,0,0],[255,255,255]] //start off with a default palette (can be overriden)
};
var ending = {};
var playerId = "A";

var names = {
	room : new Map(),
	/*tile : new Map(),*/
	sprite : new Map(),
	item : new Map(),
	/*dialog : new Map()*/
};

//stores all image data for tiles, sprites, drawings
var imageStore = {
	source: {},
	render: {}
};

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 3, // for file format / engine changes
	minor: 7 // for editor changes and bugfixes
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

function clearGameData() {
	title = "";
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette (can be overriden)
		"0" : {
			name : null,
			colors : [[0,0,0],[255,0,0],[255,255,255]]
		}
	};
	ending = {};
	isEnding = false; //todo - correct place for this?

	//stores all image data for tiles, sprites, drawings
	imageStore = {
		source: {},
		render: {}
	};

	spriteStartLocations = {};
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82
};

var prevTime = 0;
var deltaTime = 0;

//methods used to trigger gif recording
var didPlayerMoveThisFrame = false;
var onPlayerMoved = null;
// var didDialogUpdateThisFrame = false;
var onDialogUpdate = null;

function getGameNameFromURL() {
	var game = window.location.hash.substring(1);
	// console.log("game name --- " + game);
	return game;
}

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
	dialogRenderer.AttachContext(ctx);
}

var curGameData = null;
function load_game(game_data) {
	curGameData = game_data; //remember the current game (used to reset the game)
	// console.log(dialog);
	parseWorld(game_data);
	// console.log(dialog);
	renderImages();
	onready();
	// console.log(dialog);
}

function reset_cur_game() {
	if (curGameData == null) return; //can't reset if we don't have the game data
	stopGame();
	clearGameData();
	load_game(curGameData);
}

var update_interval = null;
function onready() {
	clearInterval(loading_interval);

	document.addEventListener('keydown', onkeydown);
	
	if( featureTouchDpad ) {
		document.getElementById("dpadUp").addEventListener('mousedown', dpadUp);
		document.getElementById("dpadDown").addEventListener('mousedown', dpadDown);
		document.getElementById("dpadLeft").addEventListener('mousedown', dpadLeft);
		document.getElementById("dpadRight").addEventListener('mousedown', dpadRight);
		document.getElementById("dpadMiddle").addEventListener('mousedown', dpadMiddle);
	}

	canvas.addEventListener("mousedown", onTouch);
	
	update_interval = setInterval(update,-1);
	startNarrating(title);
}

function fullscreen(el) {
    if (el.requestFullscreen) {
        return el.requestFullscreen();
    } else if (el.msRequestFullscreen) {
        return el.msRequestFullscreen();
    } else if (el.mozRequestFullScreen) {
        return el.mozRequestFullScreen();
    } else if (el.webkitRequestFullscreen) {
        return el.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    }
}

function onTouch(e) {
	console.log("MOUSEDOWN");

	if( featureTouchDpad ) {
		console.log("FULLSCREEN");
		document.getElementById("dpad").style.display = "block";
		fullscreen( document.getElementById("gameHolder") );
	}

	if( !featureOldTouch ) // Don't use old touch controls
		return;

	//dialog mode
	if (isDialogMode) {

		if (dialogBuffer.CanContinue()) {
			dialogBuffer.Continue();
		}
		else {
			dialogBuffer.Skip();
		}

		return;
	}

	if (isEnding) {
		reset_cur_game();
		return;
	}

	//walking mode
	var off = getOffset(e);
	var x = Math.floor(off.x / (tilesize*scale));
	var y = Math.floor(off.y / (tilesize*scale));
	
	//abort if you touch the square you're already on
	if (player().x == x && player().y == y) {
		return;
	}

	//did we touch a sprite?
	var touchedSprite = null;
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				touchedSprite = id;
			}
		}
	}

	//respond to sprite touch
	if (touchedSprite) {
		var spr = sprite[touchedSprite];
		// console.log(Math.abs(player().x - spr.x));
		// console.log(Math.abs(player().y - spr.y));
		if ( Math.abs(player().x - spr.x) == 0
				&& Math.abs(player().y - spr.y) == 1 )
		{
			//touched a sprite next to you
		}
		else if ( Math.abs(player().y - spr.y) == 0
				&& Math.abs(player().x - spr.x) == 1 )
		{
			//touched a sprite next to you
		}
		else
		{
			return; //oh no! touched a sprite that's out of range
		}

		startSpriteDialog( touchedSprite /*spriteId*/ );

		return;
	}

	//did we touch an open square?
	var row = room[curRoom].tilemap[y];
	// console.log(row);
	var til = row[x];
	// console.log(til);
	if ( room[curRoom].walls.indexOf(til) != -1 ) {
		//touched a wall
		return;
	}

	//find path to open square, if there is one
	var map = collisionMap(curRoom);
	var path = breadthFirstSearch( map, {x:player().x, y:player().y}, {x:x,y:y} );
	path = path.slice(1); //remove player's start square

	//console.log( pathToString(path) );

	player().walkingPath = path;
}

function breadthFirstSearch(map, from, to) {
	from.trail = [];
	var visited = [];
	var queue = [from];
	visited.push( posToString(from) );

	//console.log( "~ bfs ~");
	//console.log( posToString(from) + " to " + posToString(to) );

	while ( queue.length > 0 ) {

		//grab pos from queue and mark as visited
		var curPos = queue.shift();

		//console.log( posToString(curPos) );
		//console.log( ".. " + pathToString(curPos.trail) );
		//console.log( visited );

		if (curPos.x == to.x && curPos.y == to.y) {
			//found a path!
			var path = curPos.trail.splice(0);
			path.push( curPos );
			return path;
		}

		//look at neighbors
		neighbors(curPos).forEach( function(n) {
			var inBounds = (n.x >= 0 && n.x < 16 && n.y >= 0 && n.y < 16);
			if (inBounds) {
				var noCollision = map[n.y][n.x] <= 0;
				var notVisited = visited.indexOf( posToString(n) ) == -1;
				if (noCollision && notVisited) {
					n.trail = curPos.trail.slice();
					n.trail.push(curPos);
					queue.push( n );
					visited.push( posToString(n) );
				}
			}
		});

	}

	return []; // no path found
}

function posToString(pos) {
	return pos.x + "," + pos.y;
}

function pathToString(path) {
	var s = "";
	for (i in path) {
		s += posToString(path[i]) + " ";
	}
	return s;
}

function neighbors(pos) {
	var neighborList = [];
	neighborList.push( {x:pos.x+1, y:pos.y+0} );
	neighborList.push( {x:pos.x-1, y:pos.y+0} );
	neighborList.push( {x:pos.x+0, y:pos.y+1} );
	neighborList.push( {x:pos.x+0, y:pos.y-1} );
	return neighborList;
}

function collisionMap(roomId) {
	var map = [
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	];

	for (r in room[roomId].tilemap) {
		var row = room[roomId].tilemap[r];
		for (var c = 0; c < row.length; c++) {
			if (room[roomId].walls.indexOf( row[x] ) != -1) {
				map[r][c] = 1;
			}
		}
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			map[spr.y][spr.x] = 2;
		}
	}

	return map;
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	document.removeEventListener('keydown', onkeydown);
	clearInterval(update_interval);
}

/* loading animation */
var loading_anim_data = [
	[
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,0,0,0,0,0,0,0,
		1,0,0,0,0,0,0,1,
		1,1,1,0,0,1,1,1,
		1,1,1,1,1,0,0,1,
		1,1,1,1,1,0,0,1,
		1,1,1,0,0,1,1,1,
		1,0,0,0,0,0,0,1,
		0,0,0,0,0,0,0,0,
	]
];
var loading_anim_frame = 0;
var loading_anim_speed = 500;
var loading_interval = null;

function loadingAnimation() {
	//create image
	var loadingAnimImg = ctx.createImageData(8*scale, 8*scale);
	//draw image
	for (var y = 0; y < 8; y++) {
		for (var x = 0; x < 8; x++) {
			var i = (y * 8) + x;
			if (loading_anim_data[loading_anim_frame][i] == 1) {
				//scaling nonsense
				for (var sy = 0; sy < scale; sy++) {
					for (var sx = 0; sx < scale; sx++) {
						var pxl = 4 * ( (((y*scale)+sy) * (8*scale)) + ((x*scale)+sx) );
						loadingAnimImg.data[pxl+0] = 255;
						loadingAnimImg.data[pxl+1] = 255;
						loadingAnimImg.data[pxl+2] = 255;
						loadingAnimImg.data[pxl+3] = 255;
					}
				}
			}
		}
	}
	//put image on canvas
	ctx.putImageData(loadingAnimImg,scale*(width/2 - 4),scale*(height/2 - 4));
	//update frame
	loading_anim_frame++;
	if (loading_anim_frame >= 5) loading_anim_frame = 0;
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;
	
	//clear screen
	ctx.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
	ctx.fillRect(0,0,canvas.width,canvas.height);
	
	if (!isNarrating && !isEnding) {
		updateAnimation();
		drawRoom( room[curRoom] ); // draw world if game has begun
	}

	if (isDialogMode) { // dialog mode
		dialogRenderer.Draw( dialogBuffer, deltaTime );
		dialogBuffer.Update( deltaTime );
	}
	else if (!isEnding) {
		moveSprites();

		if (player().walkingPath.length > 0) {
			var dest = player().walkingPath[ player().walkingPath.length - 1 ];
			ctx.fillStyle = "#fff";
			ctx.globalAlpha = 0.5;
			ctx.fillRect( dest.x * tilesize*scale, dest.y * tilesize*scale, tilesize*scale, tilesize*scale );
			ctx.globalAlpha = 1;
		}
	}

	prevTime = curTime;

	//for gif recording
	if (didPlayerMoveThisFrame && onPlayerMoved != null) onPlayerMoved();
	didPlayerMoveThisFrame = false;
	// if (didDialogUpdateThisFrame && onDialogUpdate != null) onDialogUpdate();
	// didDialogUpdateThisFrame = false;
	/* hacky replacement */
	if (onDialogUpdate != null)
		dialogRenderer.SetPageFinishHandler( onDialogUpdate );
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

var moveCounter = 0;
var moveTime = 200;
function moveSprites() {
	moveCounter += deltaTime;

	if (moveCounter >= moveTime) {

		for (id in sprite) {
			var spr = sprite[id];
			if (spr.walkingPath.length > 0) {
				//move sprite
				var nextPos = spr.walkingPath.shift();
				spr.x = nextPos.x;
				spr.y = nextPos.y;


				var end = getEnding( spr.room, spr.x, spr.y );
				var ext = getExit( spr.room, spr.x, spr.y );
				var itmIndex = getItemIndex( spr.room, spr.x, spr.y );
				if (end) { //if the sprite hits an ending
					if (id === playerId) { // only the player can end the game
						startNarrating( ending[end.id], true /*isEnding*/ );
					}
				}
				else if (ext) { //if the sprite hits an exit
					//move it to another scene
					spr.room = ext.dest.room;
					spr.x = ext.dest.x;
					spr.y = ext.dest.y;
					if (id === playerId) {
						//if the player changes scenes, change the visible scene
						curRoom = ext.dest.room;
					}
				}
				else if(itmIndex > -1) {
					var itm = room[ spr.room ].items[ itmIndex ];
					room[ spr.room ].items.splice( itmIndex, 1 );
					if( spr.inventory[ itm.id ] )
						spr.inventory[ itm.id ] += 1;
					else
						spr.inventory[ itm.id ] = 1;

					if(id === playerId)
						startItemDialog( itm.id  /*itemId*/ );

					// stop moving : is this a good idea?
					spr.walkingPath = [];
				}

				if (id === playerId) didPlayerMoveThisFrame = true;
			}
		}

		moveCounter = 0;
	}

}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

function onkeydown(e) {
	// console.log(e.keyCode);
	// console.log(dialog);
	e.preventDefault();

	if (isDialogMode) {

		/* CONTINUE DIALOG */

		if (dialogBuffer.CanContinue()) {
			dialogBuffer.Continue();
		}
		else {
			dialogBuffer.Skip();
		}

	}
	else if (isEnding) {
		/* RESTART GAME */
		reset_cur_game();
	}
	else {

		/* WALK */

		var spr = null;

		if ( (e.keyCode == key.left || e.keyCode == key.a) && !(spr = getSpriteLeft()) && !isWallLeft()) {
			player().x -= 1;
			didPlayerMoveThisFrame = true;
		}
		else if ( (e.keyCode == key.right || e.keyCode == key.d) && !(spr = getSpriteRight()) && !isWallRight()) {
			player().x += 1;
			didPlayerMoveThisFrame = true;
		}
		else if ( (e.keyCode == key.up || e.keyCode == key.w) && !(spr = getSpriteUp()) && !isWallUp()) {
			player().y -= 1;
			didPlayerMoveThisFrame = true;
		}
		else if ( (e.keyCode == key.down || e.keyCode == key.s) && !(spr = getSpriteDown()) && !isWallDown()) {
			player().y += 1;
			didPlayerMoveThisFrame = true;
		}
		
		var ext = getExit( player().room, player().x, player().y );
		var end = getEnding( player().room, player().x, player().y );
		var itmIndex = getItemIndex( player().room, player().x, player().y );
		if (end) {
			startNarrating( ending[end.id], true /*isEnding*/ );
		}
		else if (ext) {
			player().room = ext.dest.room;
			player().x = ext.dest.x;
			player().y = ext.dest.y;
			curRoom = ext.dest.room;
		}
		else if (spr) {
			startSpriteDialog( spr /*spriteId*/ );
		}
		else if (itmIndex > -1) {
			// TODO pick up items (what about touch?)
			// console.log("HIT ITM ");
			// console.log( itmIndex );
			var itm = room[ player().room ].items[ itmIndex ];
			// console.log(itm);
			room[ player().room ].items.splice( itmIndex, 1 );
			if( player().inventory[ itm.id ] )
				player().inventory[ itm.id ] += 1;
			else
				player().inventory[ itm.id ] = 1;

			startItemDialog( itm.id  /*itemId*/ );

			// console.log( player().inventory );
		}

		/* RESTART GAME */
		if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
			if ( confirm("Restart the game?") ) {
				reset_cur_game();
			}
		}
	}

}

function dpad(e, keyCode) {
	e.keyCode = keyCode; // turn this mouse event into a fake key event
	onkeydown( e );
}

function dpadUp(e) {
	dpad( e, key.up );
}

function dpadDown(e) {
	dpad( e, key.down );
}

function dpadLeft(e) {
	dpad( e, key.left );
}

function dpadRight(e) {
	dpad( e, key.right );
}

function dpadMiddle(e) {
	dpad( e, key.space );
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return isWall( player().x - 1, player().y ) || (player().x - 1 < 0);
}

function isWallRight() {
	return isWall( player().x + 1, player().y ) || (player().x + 1 >= 16);
}

function isWallUp() {
	return isWall( player().x, player().y - 1 ) || (player().y - 1 < 0);
}

function isWallDown() {
	return isWall( player().x, player().y + 1 ) || (player().y + 1 >= 16);
}

function isWall(x,y) {
	// console.log(x + " " + y);
	var i = getRoom().walls.indexOf( getTile(x,y) );
	return i > -1;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x,y) {
	// console.log(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	resetFlags();

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// console.log(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i);
		}
		else if (getType(curLine) === "END") {
			i = parseEnding(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}
	placeSprites();
	if (player().room != null) {
		curRoom = player().room;
	}

	console.log(names);
}

//TODO this is in progress and doesn't support all features
function serializeWorld() {
	var worldStr = "";
	/* TITLE */
	worldStr += title + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* PALETTE */
	for (id in palette) {
		worldStr += "PAL " + id + "\n";
		if( palette[id].name != null )
			worldStr += "NAME " + palette[id].name + "\n";
		for (i in getPal(id)) {
			for (j in getPal(id)[i]) {
				worldStr += getPal(id)[i][j];
				if (j < 2) worldStr += ",";
			}
			worldStr += "\n";
		}
		worldStr += "\n";
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null) {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		worldStr += "DLG " + id + "\n";
		worldStr += dialog[id] + "\n";
		worldStr += "\n";
	}
	/* ENDINGS */
	for (id in ending) {
		worldStr += "END " + id + "\n";
		worldStr += ending[id] + "\n";
		worldStr += "\n";
	}
	return worldStr;
}

function serializeDrawing(drwId) {
	var drwStr = "";
	for (f in imageStore.source[drwId]) {
		for (y in imageStore.source[drwId][f]) {
			var rowStr = "";
			for (x in imageStore.source[drwId][f][y]) {
				rowStr += imageStore.source[drwId][f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (imageStore.source[drwId].length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//console.log(id);
		//console.log( spriteStartLocations[id] );
		//console.log(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//console.log(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	title = lines[i];
	i++;
	return i;
}

function parseRoom(lines, i) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// console.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				}
			};
			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId( lines[i] );
			var endCoords = getCoord( lines[i], 2 );
			var end = {
				id : endId,
				x : parseInt( endCoords[0] ),
				y : parseInt( endCoords[1] )
			};
			room[id].endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room[ name ] = id;
		}
		i++;
	}
	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if(args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store tile source
		drwId = "TIL_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 1; //default palette color index is 1
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			colorIndex = parseInt( getId(lines[i]) );
		}
		i++;
	}

	//tile data
	tile[id] = {
		drw : drwId, //drawing id
		col : colorIndex,
		animation : {
			isAnimated : (imageStore.source[drwId].length > 1),
			frameIndex : 0,
			frameCount : imageStore.source[drwId].length
		}
	};
	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store sprite source
		drwId = "SPR_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.sprite[name] = id;
		}
		i++;
	}

	//sprite data
	sprite[id] = {
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		room : null, //default location is "offstage"
		x : -1,
		y : -1,
		walkingPath : [], //tile by tile movement path (isn't saved)
		animation : {
			isAnimated : (imageStore.source[drwId].length > 1),
			frameIndex : 0,
			frameCount : imageStore.source[drwId].length
		},
		inventory : {},
		name : name
	};
	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store item source
		drwId = "ITM_" + id; // these prefixes are maybe a terrible way to differentiate drawing tyepes :/
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getArg( lines[i], 1 ) );
		}
		// else if (getType(lines[i]) === "POS") {
		// 	/* STARTING POSITION */
		// 	var posArgs = lines[i].split(" ");
		// 	var roomId = posArgs[1];
		// 	var coordArgs = posArgs[2].split(",");
		// 	spriteStartLocations[id] = {
		// 		room : roomId,
		// 		x : parseInt(coordArgs[0]),
		// 		y : parseInt(coordArgs[1])
		// 	};
		// }
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.item[name] = id;
		}
		i++;
	}

	//item data
	item[id] = {
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		// room : null, //default location is "offstage"
		// x : -1,
		// y : -1,
		animation : {
			isAnimated : (imageStore.source[drwId].length > 1),
			frameIndex : 0,
			frameCount : imageStore.source[drwId].length
		},
		name : name
	};

	// console.log("ITM " + id);
	// console.log(item[id]);

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	imageStore.source[drwId] = []; //init list of frames
	imageStore.source[drwId].push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		imageStore.source[drwId][frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				imageStore.source[drwId].push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	//console.log(imageStore.source[drwId]);
	return i;
}

function renderImages() {
	console.log(" -- RENDER IMAGES -- ");

	//init image store
	for (pal in palette) {
		imageStore.render[pal] = {
			"1" : {}, //images with primary color index 1 (usually tiles)
			"2" : {}  //images with primary color index 2 (usually sprites)
		};
	}

	//render images required by sprites
	for (s in sprite) {
		var spr = sprite[s];
		renderImageForAllPalettes( spr );
	}
	//render images required by tiles
	for (t in tile) {
		var til = tile[t];
		renderImageForAllPalettes( til );
	}
	//render images required by tiles
	for (i in item) {
		var itm = item[i];
		renderImageForAllPalettes( itm );
	}
}

function renderImageForAllPalettes(drawing) {
	console.log("RENDER IMAGE");
	for (pal in palette) {
		console.log(pal);
		var col = drawing.col;
		var colStr = "" + col;
		console.log(drawing);
		console.log(drawing.drw);
		console.log(imageStore);
		var imgSrc = imageStore.source[ drawing.drw ];
		if ( imgSrc.length <= 1 ) {
			// non-animated drawing
			var frameSrc = imgSrc[0];
			console.log(drawing);
			console.log(imageStore);
			imageStore.render[pal][colStr][drawing.drw] = imageDataFromImageSource( frameSrc, pal, col );
		}
		else {
			// animated drawing
			var frameCount = 0;
			for (f in imgSrc) {
				var frameSrc = imgSrc[f];
				var frameId = drawing.drw + "_" + frameCount;
				imageStore.render[pal][colStr][frameId] = imageDataFromImageSource( frameSrc, pal, col );
				frameCount++;
			}
		}		
	}
}

function imageDataFromImageSource(imageSource, pal, col) {
	//console.log(imageSource);

	var img = ctx.createImageData(tilesize*scale,tilesize*scale);
	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = imageSource[y][x];
			for (var sy = 0; sy < scale; sy++) {
				for (var sx = 0; sx < scale; sx++) {
					var pxl = (((y * scale) + sy) * tilesize * scale * 4) + (((x*scale) + sx) * 4);
					if (px === 1) {
						img.data[pxl + 0] = getPal(pal)[col][0]; //ugly
						img.data[pxl + 1] = getPal(pal)[col][1];
						img.data[pxl + 2] = getPal(pal)[col][2];
						img.data[pxl + 3] = 255;
					}
					else { //ch === 0
						img.data[pxl + 0] = getPal(pal)[0][0];
						img.data[pxl + 1] = getPal(pal)[0][1];
						img.data[pxl + 2] = getPal(pal)[0][2];
						img.data[pxl + 3] = 255;
					}
				}
			}
		}
	}
	return img;
}

function parseDialog(lines, i) {
	var id = getId(lines[i]);
	i++;
	var text = "";
	if( featureNewScript ) {
		while (lines[i].length > 0) {
			text += lines[i] + "\n";
			i++;
		}
	}
	else {
		text = lines[i];
	}
	// console.log(text);
	dialog[id] = text;
	// console.log(dialog[id]);
	// console.log(dialog);
	return i;
}

function parseEnding(lines, i) {
	var id = getId(lines[i]);
	i++;
	var text = lines[i];
	i++;
	ending[id] = text;
	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(img,x,y,context) {
	if (!context) { //optional pass in context; otherwise, use default
		context = ctx;
	}
	context.putImageData(img,x*tilesize*scale,y*tilesize*scale);
}

function drawSprite(img,x,y,context) { //this may differ later (or not haha)
	drawTile(img,x,y,context);
}

function drawItem(img,x,y,context) {
	drawTile(img,x,y,context); //TODO these methods are dumb and repetitive
}

function drawRoom(room,context) {
	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			if (id != "0") {
				//console.log(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// console.log(id);
					drawTile( getTileImage(tile[id],getRoomPal(room.id)), j, i, context );
				}
			}
		}
	}
	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem( getItemImage(item[itm.id],getRoomPal(room.id)), itm.x, itm.y, context );
	}
	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite( getSpriteImage(spr,getRoomPal(room.id)), spr.x, spr.y, context );
		}
	}
}

function getTileImage(t,palId,frameIndex) {
	if( frameIndex === undefined ) frameIndex = null; // no default parameter support on iOS

	var drwId = t.drw;

	if (!palId) palId = curPal();

	if ( t.animation.isAnimated ) {
		if (frameIndex != null) { // use optional provided frame index
			// console.log("GET TILE " + frameIndex);
			drwId += "_" + frameIndex;
		}
		else { // or the one bundled with the tile
			drwId += "_" + t.animation.frameIndex;
		}
	}
	return imageStore.render[ palId ][ t.col ][ drwId ];
}

function getSpriteImage(s,palId,frameIndex) {
	if( frameIndex === undefined ) frameIndex = null; // no default parameter support on iOS

	var drwId = s.drw;

	if (!palId) palId = curPal();

	if ( s.animation.isAnimated ) {
		if (frameIndex != null) {
			drwId += "_" + frameIndex;
		}
		else {
			drwId += "_" + s.animation.frameIndex;
		}
	}

	return imageStore.render[ palId ][ s.col ][ drwId ];
}

function getItemImage(itm,palId,frameIndex) { //aren't these all the same????
	if( frameIndex === undefined ) frameIndex = null; // no default parameter support on iOS

	var drwId = itm.drw;
	// console.log(drwId);

	if (!palId) palId = curPal();

	if ( itm.animation.isAnimated ) {
		if (frameIndex != null) {
			drwId += "_" + frameIndex;
		}
		else {
			drwId += "_" + itm.animation.frameIndex;
		}
	}

	// console.log(imageStore.render[ palId ][ itm.col ]);
	// console.log(imageStore.render[ palId ][ itm.col ][ drwId ]);
	return imageStore.render[ palId ][ itm.col ][ drwId ];
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return "0";
		}
	}
	return "0";	
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialog = new Dialog();
var dialogRenderer = dialog.CreateRenderer();
var dialogBuffer = dialog.CreateBuffer();

function onExitDialog() {
	isDialogMode = false;
	if (isNarrating) isNarrating = false;
}

function startNarrating(dialogStr,end) {
	if(end === undefined) end = false;

	isNarrating = true;
	isEnding = end;
	startDialog(dialogStr);
}

function startItemDialog(itemId) {
	var dialogId = item[itemId].dlg;
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr);
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg ? spr.dlg : spriteId;
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr);
	}
}

function startDialog(dialogStr) {
	if(dialogStr.length <= 0) {
		onExitDialog();
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( isNarrating /*centered*/ );
	dialogBuffer.Start( dialogStr, onExitDialog );
}

/* NEW SCRIPT STUFF */
var script = new Script();

/* FEATURE FLAGS */
var featureNewScript = false;
var featureNewDialog = false;
var featureOldTouch = false;
var featureTouchDpad = false;
</script>

</head>


<!-- DOCUMENT BODY -->
<audio autoplay loop preload><source src="train.wav" type="audio/wav"></audio>
<body onload='startExportedGame()'>
	<div id="gameHolder">
		<!-- GAME CANVAS -->
		<canvas id='game'></canvas>

		<!-- VIRTUAL D-PAD -->
<!-- 		<div id="dpad" style="display:none;">
			<div class="dpadRow">
				<div class="dpadBox"></div>
				<div class="dpadBox" id="dpadUp"></div>
				<div class="dpadBox"></div>
			</div>
			<div class="dpadRow">
				<div class="dpadBox" id="dpadLeft"></div>
				<div class="dpadBox" id="dpadMiddle"></div>
				<div class="dpadBox" id="dpadRight"></div>
			</div>
			<div class="dpadRow">
				<div class="dpadBox"></div>
				<div class="dpadBox" id="dpadDown"></div>
				<div class="dpadBox"></div>
			</div>
		</div> -->

	</div>
</body>


</html>
	